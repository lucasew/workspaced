package shell

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"
	envdriver "workspaced/pkg/driver/env"
	execdriver "workspaced/pkg/driver/exec"
	"workspaced/pkg/shellgen"
	"workspaced/pkg/version"

	"github.com/spf13/cobra"
)

func getInitCommand() *cobra.Command {
	var force bool
	var profile bool

	cmd := &cobra.Command{
		Use:   "init [shell]",
		Short: "Generate shell initialization script",
		Long: `Generates shell initialization by concatenating prelude scripts.
Uses caching for performance - regenerates only when source files change.`,
		Args: cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			startTime := time.Now()
			defer func() {
				if profile {
					slog.Info("shell init total time", "duration", time.Since(startTime))
				}
			}()
			shell := "bash"
			if len(args) > 0 {
				shell = args[0]
			}

			// Find dotfiles root
			dotfilesRoot, err := findDotfilesRoot()
			if err != nil {
				return fmt.Errorf("failed to find dotfiles root: %w", err)
			}

			preludeDir := filepath.Join(dotfilesRoot, "bin", "prelude")

			// Get cache path
			cacheDir := getCacheDir()
			if err := os.MkdirAll(cacheDir, 0755); err != nil {
				return fmt.Errorf("failed to create cache directory: %w", err)
			}

			buildID := version.GetBuildID()
			cacheFile := filepath.Join(cacheDir, fmt.Sprintf("shell-init-%s-%s.bash", shell, buildID))

			// Check if cache exists (build ID already in filename)
			if !force {
				if content, err := os.ReadFile(cacheFile); err == nil {
					if profile {
						slog.Info("shell init cache hit", "cache_file", cacheFile)
					}
					fmt.Print(string(content))
					return nil
				}
			}
			if profile {
				slog.Info("shell init cache miss, generating")
			}

			// Read all prelude files in parallel
			t1 := time.Now()
			allFiles, err := filepath.Glob(filepath.Join(preludeDir, "*.sh"))
			if err != nil {
				return fmt.Errorf("failed to list prelude files: %w", err)
			}
			if profile {
				slog.Info("shell init glob files", "duration", time.Since(t1), "files", len(allFiles))
			}

			// Separate .source.sh files from regular .sh files
			var files []string
			sourceFiles := make(map[string]string) // basename -> path

			for _, file := range allFiles {
				basename := filepath.Base(file)
				if strings.HasSuffix(basename, ".source.sh") {
					// Skip mise .source.sh as it's generated in Go
					if strings.Contains(basename, "mise") {
						continue
					}
					// Map the base name without .source.sh extension
					key := strings.TrimSuffix(basename, ".source.sh")
					sourceFiles[key] = file
				} else {
					files = append(files, file)
				}
			}
			sort.Strings(files)

			// Read all files in parallel
			type fileContent struct {
				path    string
				content string
				err     error
			}

			results := make(chan fileContent, len(files))
			var wg sync.WaitGroup

			for _, file := range files {
				wg.Add(1)
				go func(path string) {
					defer wg.Done()
					content, err := os.ReadFile(path)
					results <- fileContent{
						path:    path,
						content: string(content),
						err:     err,
					}
				}(file)
			}

			// Wait and close results channel
			go func() {
				wg.Wait()
				close(results)
			}()

			// Collect results maintaining order
			contentMap := make(map[string]string)
			for result := range results {
				if result.err != nil {
					return fmt.Errorf("failed to read %s: %w", result.path, result.err)
				}
				contentMap[result.path] = result.content
			}

			// Execute .source.sh files in parallel
			t2 := time.Now()
			sourceOutputs, err := executeSourceFiles(sourceFiles)
			if err != nil {
				return fmt.Errorf("failed to execute source files: %w", err)
			}
			if profile {
				slog.Info("shell init executed .source.sh files", "duration", time.Since(t2), "files", len(sourceFiles))
			}

			// Build output in order
			var output strings.Builder
			output.WriteString("# Generated by workspaced shell init\n")
			output.WriteString("# This file is cached for performance\n")
			output.WriteString("# Commands executed in parallel for faster loading\n\n")

			// Generate all inline shell initialization code in parallel
			t3 := time.Now()
			inlineCode, err := shellgen.Generate()
			if err != nil {
				return fmt.Errorf("failed to generate inline shell initialization: %w", err)
			}
			if profile {
				slog.Info("shell init generated inline code", "duration", time.Since(t3))
			}
			output.WriteString(inlineCode)

			for _, file := range files {
				basename := filepath.Base(file)
				baseKey := strings.TrimSuffix(basename, ".sh")

				// Skip files generated inline above
				if strings.Contains(basename, "workspaced-init") ||
					strings.Contains(basename, "workspaced-history") {
					continue
				}

				// Check if there's a .source.sh file - if so, use ONLY its output
				if sourceOutput, hasSource := sourceOutputs[baseKey]; hasSource {
					fmt.Fprintf(&output, "# Source: %s (generated by %s.source.sh)\n", basename, baseKey)
					output.WriteString(sourceOutput)
					if !strings.HasSuffix(sourceOutput, "\n") {
						output.WriteString("\n")
					}
					output.WriteString("\n")
					continue
				}

				// Regular file processing
				content := contentMap[file]
				fmt.Fprintf(&output, "# Source: %s\n", basename)
				output.WriteString(content)

				if !strings.HasSuffix(content, "\n") {
					output.WriteString("\n")
				}
				output.WriteString("\n")
			}

			result := output.String()

			// Save to cache
			if err := os.WriteFile(cacheFile, []byte(result), 0644); err != nil {
				// Non-fatal, continue
				slog.Warn("failed to write shell init cache", "cache_file", cacheFile, "error", err)
			}

			fmt.Print(result)
			return nil
		},
	}

	cmd.Flags().BoolVarP(&force, "force", "f", false, "Force regeneration, ignore cache")
	cmd.Flags().BoolVarP(&profile, "profile", "p", false, "Show timing information for each step")

	return cmd
}

func findDotfilesRoot() (string, error) {
	// Use unified dotfiles detection
	root, err := envdriver.GetDotfilesRoot(context.Background())
	if err != nil {
		return "", fmt.Errorf("dotfiles root not found: %w", err)
	}

	// Verify it has bin/prelude (shell init specific requirement)
	if info, err := os.Stat(filepath.Join(root, "bin", "prelude")); err == nil && info.IsDir() {
		return root, nil
	}

	return "", fmt.Errorf("dotfiles root found at %s but missing bin/prelude", root)
}

func getCacheDir() string {
	if xdgCache := os.Getenv("XDG_CACHE_HOME"); xdgCache != "" {
		return filepath.Join(xdgCache, "workspaced")
	}
	return filepath.Join(os.Getenv("HOME"), ".cache", "workspaced")
}

// generateColorCodes generates ANSI color codes inline without calling external commands

// executeSourceFiles executes all .source.sh files in parallel and returns their outputs
func executeSourceFiles(sourceFiles map[string]string) (map[string]string, error) {
	if len(sourceFiles) == 0 {
		return make(map[string]string), nil
	}

	type sourceResult struct {
		key    string
		output string
		err    error
	}

	results := make(chan sourceResult, len(sourceFiles))
	var wg sync.WaitGroup

	for key, path := range sourceFiles {
		wg.Add(1)
		go func(k, p string) {
			defer wg.Done()

			// Execute the source file with bash using execdriver
			cmd, err := execdriver.Run(context.Background(), "bash", p)
			if err != nil {
				results <- sourceResult{
					key:    k,
					output: "",
					err:    err,
				}
				return
			}
			cmd.Env = os.Environ()
			output, err := cmd.Output()

			results <- sourceResult{
				key:    k,
				output: string(output),
				err:    err,
			}
		}(key, path)
	}

	go func() {
		wg.Wait()
		close(results)
	}()

	// Collect results
	outputMap := make(map[string]string)
	for result := range results {
		if result.err != nil {
			// Log warning but don't fail - just skip this source file
			slog.Warn("failed to execute .source.sh", "source", result.key+".source.sh", "error", result.err)
			continue
		}
		outputMap[result.key] = result.output
	}

	return outputMap, nil
}
